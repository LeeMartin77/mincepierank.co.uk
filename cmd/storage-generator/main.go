package main

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

// built following this guide https://dev.to/hlubek/metaprogramming-with-go-or-how-to-build-code-generators-that-parse-go-code-2k3j

func main() {
	if len(os.Args) != 3 {
		failErr(fmt.Errorf("expected exactly two arguments: <source type> and <table name>"))
	}
	sourceType := os.Args[1]
	tableName := os.Args[2]
	sourceTypePackage, sourceTypeName := splitSourceType(sourceType)

	pkg := loadPackage(sourceTypePackage)

	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s",
			sourceTypeName, pkg))
	}

	if _, ok := obj.(*types.TypeName); !ok {
		failErr(fmt.Errorf("%v is not a named type", obj))
	}

	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		failErr(fmt.Errorf("type %v is not a struct", obj))
	}

	err := generate(tableName, sourceTypeName, structType)
	if err != nil {
		failErr(err)
	}
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.MyType"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	fmt.Println(sourceTypePackage)
	fmt.Println(sourceTypeName)
	return sourceTypePackage, sourceTypeName
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var structColPattern = regexp.MustCompile(`col:"([^"]+)"`)

func generate(tableName string, sourceTypeName string, structType *types.Struct) error {
	goPackage := os.Getenv("GOPACKAGE")

	f := jen.NewFile(goPackage)

	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	// 6. Build the target file name
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "." + strings.ToLower(sourceTypeName) + ".gen.go"
	cblck := []jen.Code{}
	cblck = append(cblck, jen.Id("args").Op(":=").Op("[]").Interface().Op("{"))
	sqlstr := fmt.Sprintf(`INSERT INTO %s (`, tableName)
	valuecols := ""
	valuesstr := ") VALUES ("
	questionmarks := ""
	end := ") ON CONFLICT DO NOTHING"
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		tagValue := structType.Tag(i)
		matches := structColPattern.FindStringSubmatch(tagValue)
		if matches == nil {
			continue
		}
		if len(valuecols) > 0 {
			// need a comma
			valuecols += ","
			questionmarks += ","
		}
		col := matches[1]
		valuecols += col
		questionmarks += "?"
		cblck = append(cblck, jen.Id("c").Dot(field.Name()).Op(","))
	}

	cblck = append(cblck, jen.Op("}"))
	cblck = append(cblck, jen.Id("sql").Op(":=").Op(fmt.Sprintf("\"%s%s%s%s%s\"", sqlstr, valuecols, valuesstr, questionmarks, end)))

	cblck = append(cblck, jen.Id("_").Op(",").Id("err").Op(":=").Id("pg").Dot("Exec").Params(
		jen.Id("ctx"), jen.Id("sql"), jen.Id("args").Op("..."),
	))
	cblck = append(cblck, jen.If(jen.Id("err").Op("!=").Nil()).Block(
		jen.Return(jen.Nil(), jen.Id("err")),
	))
	cblck = append(cblck, jen.Return(jen.Op("&").Id("c"), jen.Nil()))
	f.ImportName("github.com/jackc/pgx/v5/pgxpool", "pgxpool")

	f.Commentf("Insert new '%s' into table '%s' - duplicate ids is a no-op", sourceTypeName, tableName)
	f.Func().Id(sourceTypeName+"Create").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("pg").Op("*").Qual(
			"github.com/jackc/pgx/v5/pgxpool",
			"Pool",
		),
		jen.Id("c").Id(sourceTypeName),
	).Params(jen.Op("*").Id(sourceTypeName), jen.Error()).Block(cblck...)
	return f.Save(targetFilename)
}
