// Code generated by generator, DO NOT EDIT.
package generated

import (
	"context"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	types "github.com/leemartin77/mincepierank.co.uk/internal/storage/types"
)

// Insert new 'MakerPieRankingYearly' into table 'maker_pie_ranking_yearly' - duplicate ids is a no-op
func MakerPieRankingYearlyCreate(ctx context.Context, pg *pgxpool.Pool, c types.MakerPieRankingYearly) (*types.MakerPieRankingYearly, error) {
	args := []interface{}{
		c.Year,
		c.MakerId,
		c.Id,
		c.UserId,
		c.Pastry,
		c.Filling,
		c.Topping,
		c.Looks,
		c.Value,
		c.Notes,
		c.LastUpdated,
	}
	sql := "INSERT INTO maker_pie_ranking_yearly (year,makerid,id,userid,pastry,filling,topping,looks,value,notes,last_updated) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11) ON CONFLICT DO NOTHING"
	_, err := pg.Exec(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	return &c, nil
}

// Update 'MakerPieRankingYearly' in table 'maker_pie_ranking_yearly' based on id columns
func MakerPieRankingYearlyUpdate(ctx context.Context, pg *pgxpool.Pool, u types.MakerPieRankingYearly) (*types.MakerPieRankingYearly, error) {
	parameters := []interface{}{}
	parameters = append(parameters, u.Year)
	parameters = append(parameters, u.MakerId)
	parameters = append(parameters, u.Id)
	parameters = append(parameters, u.UserId)
	parameters = append(parameters, u.Pastry)
	parameters = append(parameters, u.Filling)
	parameters = append(parameters, u.Topping)
	parameters = append(parameters, u.Looks)
	parameters = append(parameters, u.Value)
	parameters = append(parameters, u.Notes)
	parameters = append(parameters, u.LastUpdated)
	sql := "UPDATE maker_pie_ranking_yearly SET pastry=$5,filling=$6,topping=$7,looks=$8,value=$9,notes=$10,last_updated=$11 WHERE year=$1 AND makerid=$2 AND id=$3 AND userid=$4"
	_, err := pg.Exec(ctx, sql, parameters...)
	if err != nil {
		return nil, err
	}
	return &u, nil
}

// Read 'MakerPieRankingYearly' in table 'maker_pie_ranking_yearly' based on id columns - nil but no error if not found
func MakerPieRankingYearlyRead(ctx context.Context, pg *pgxpool.Pool, Year int32, MakerId string, Id string, UserId string) (*types.MakerPieRankingYearly, error) {
	r := types.MakerPieRankingYearly{}
	identifiers := []interface{}{}
	identifiers = append(identifiers, Year)
	identifiers = append(identifiers, MakerId)
	identifiers = append(identifiers, Id)
	identifiers = append(identifiers, UserId)
	sql := "SELECT year, makerid, id, userid, pastry, filling, topping, looks, value, notes, last_updated FROM maker_pie_ranking_yearly  WHERE year = $1 AND makerid = $2 AND id = $3 AND userid = $4"
	res := pg.QueryRow(ctx, sql, identifiers...)
	err := res.Scan(&r.Year, &r.MakerId, &r.Id, &r.UserId, &r.Pastry, &r.Filling, &r.Topping, &r.Looks, &r.Value, &r.Notes, &r.LastUpdated)
	if err == pgx.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &r, nil
}

// Deletes 'MakerPieRankingYearly' in table 'maker_pie_ranking_yearly' based on id columns - no error if not found
func MakerPieRankingYearlyDelete(ctx context.Context, pg *pgxpool.Pool, Year int32, MakerId string, Id string, UserId string) error {
	identifiers := []interface{}{}
	identifiers = append(identifiers, Year)
	identifiers = append(identifiers, MakerId)
	identifiers = append(identifiers, Id)
	identifiers = append(identifiers, UserId)
	sql := "DELETE FROM maker_pie_ranking_yearly WHERE year = $1 AND makerid = $2 AND id = $3 AND userid = $4"
	_, err := pg.Exec(ctx, sql, identifiers...)
	if err != nil {
		return err
	}
	return nil
}
