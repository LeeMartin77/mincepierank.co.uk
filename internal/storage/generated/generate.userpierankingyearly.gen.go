// Code generated by generator, DO NOT EDIT.
package generated

import (
	"context"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	types "github.com/leemartin77/mincepierank.co.uk/internal/storage/types"
)

// Insert new 'UserPieRankingYearly' into table 'user_pie_ranking_yearly' - duplicate ids is a no-op
func UserPieRankingYearlyCreate(ctx context.Context, pg *pgxpool.Pool, c types.UserPieRankingYearly) (*types.UserPieRankingYearly, error) {
	args := []interface{}{
		c.Year,
		c.PieId,
		c.UserId,
		c.Pastry,
		c.Filling,
		c.Topping,
		c.Looks,
		c.Value,
		c.Notes,
		c.LastUpdated,
	}
	sql := "INSERT INTO user_pie_ranking_yearly (year,pieid,userid,pastry,filling,topping,looks,value,notes,last_updated) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) ON CONFLICT DO NOTHING"
	_, err := pg.Exec(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	return &c, nil
}

// Update 'UserPieRankingYearly' in table 'user_pie_ranking_yearly' based on id columns
func UserPieRankingYearlyUpdate(ctx context.Context, pg *pgxpool.Pool, u types.UserPieRankingYearly) (*types.UserPieRankingYearly, error) {
	parameters := []interface{}{}
	parameters = append(parameters, u.Year)
	parameters = append(parameters, u.PieId)
	parameters = append(parameters, u.UserId)
	parameters = append(parameters, u.Pastry)
	parameters = append(parameters, u.Filling)
	parameters = append(parameters, u.Topping)
	parameters = append(parameters, u.Looks)
	parameters = append(parameters, u.Value)
	parameters = append(parameters, u.Notes)
	parameters = append(parameters, u.LastUpdated)
	sql := "UPDATE user_pie_ranking_yearly SET pastry=$4,filling=$5,topping=$6,looks=$7,value=$8,notes=$9,last_updated=$10 WHERE year=$1 AND pieid=$2 AND userid=$3"
	_, err := pg.Exec(ctx, sql, parameters...)
	if err != nil {
		return nil, err
	}
	return &u, nil
}

// Read 'UserPieRankingYearly' in table 'user_pie_ranking_yearly' based on id columns - nil but no error if not found
func UserPieRankingYearlyRead(ctx context.Context, pg *pgxpool.Pool, Year int32, PieId string, UserId string) (*types.UserPieRankingYearly, error) {
	r := types.UserPieRankingYearly{}
	identifiers := []interface{}{}
	identifiers = append(identifiers, Year)
	identifiers = append(identifiers, PieId)
	identifiers = append(identifiers, UserId)
	sql := "SELECT year, pieid, userid, pastry, filling, topping, looks, value, notes, last_updated FROM user_pie_ranking_yearly  WHERE year = $1 AND pieid = $2 AND userid = $3"
	res := pg.QueryRow(ctx, sql, identifiers...)
	err := res.Scan(&r.Year, &r.PieId, &r.UserId, &r.Pastry, &r.Filling, &r.Topping, &r.Looks, &r.Value, &r.Notes, &r.LastUpdated)
	if err == pgx.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &r, nil
}

// Deletes 'UserPieRankingYearly' in table 'user_pie_ranking_yearly' based on id columns - no error if not found
func UserPieRankingYearlyDelete(ctx context.Context, pg *pgxpool.Pool, Year int32, PieId string, UserId string) error {
	identifiers := []interface{}{}
	identifiers = append(identifiers, Year)
	identifiers = append(identifiers, PieId)
	identifiers = append(identifiers, UserId)
	sql := "DELETE FROM user_pie_ranking_yearly WHERE year = $1 AND pieid = $2 AND userid = $3"
	_, err := pg.Exec(ctx, sql, identifiers...)
	if err != nil {
		return err
	}
	return nil
}
